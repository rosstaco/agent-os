# Task List Creation

## Core Responsibilities

1. **Analyze available roles**: Analyze the available implementer roles and their specialties so that you can assign appropriate agents to each tasks group
2. **Plan task execution order**: Break the requirements into a list of tasks in an order that takes their dependencies into account.
3. **Group tasks by specialist agent**: Group tasks that should be handled by the same specialist agent together.
4. **Create Tasks list**: Create the markdown tasks list broken into groups with sub-tasks and recommended specialist agent.

## Workflow

### Step 1: Analyze Available Specialist Roles (Agents)

Read the file `agent-os/roles/implementers.yml`.

- Review each `implementer`'s `areas_of_responsibility` (specialty areas) and THINK HARD
- Identify which implementers are best suited for different types of tasks
- Consider implementers availability and any usage constraints
- Use your knowledge of implementers areas of responsibilities (specializations) when you assign them to the tasks you will create in the next step.

### Step 2: Create Tasks Breakdown with Subagent Role Assignments

Use your knowledge of the available role specialists from Step 1 to make appropriate task group assignments.

Generate `agent-os/specs/[current-spec]/tasks.md` with suggested subagents (a.k.a. implementers).

**Important**: The exact tasks, task groups, and organization will vary based on the feature's specific requirements. The following is an example format - adapt the content of the tasks list to match what the feature actually needs.

```markdown
# Task Breakdown: [Feature Name]

## Overview
Total Tasks: [count]
Assigned roles: [list from registry]

## Task List

### Database Layer

#### Task Group 1: Data Models and Migrations
**Assigned implementer:** database-engineer
**Dependencies:** None

- [ ] 1.0 Complete database layer
  - [ ] 1.1 Write tests for [Model] functionality
    - Model validation tests
    - Association tests
    - Method behavior tests
    - Migration tests
  - [ ] 1.2 Create [Model] with validations
    - Fields: [list]
    - Validations: [list]
    - Reuse pattern from: [existing model if applicable]
  - [ ] 1.3 Create migration for [table]
    - Add indexes for: [fields]
    - Foreign keys: [relationships]
  - [ ] 1.4 Set up associations
    - [Model] has_many [related]
    - [Model] belongs_to [parent]
  - [ ] 1.5 Ensure all database layer tests pass
    - Run model tests written in 1.1
    - Verify migrations run successfully
    - Confirm associations work correctly

**Acceptance Criteria:**
- All tests written in 1.1 pass
- Models pass validation tests
- Migrations run successfully
- Associations work correctly

### API Layer

#### Task Group 2: API Endpoints
**Assigned implementer:** api-engineer
**Dependencies:** Task Group 1

- [ ] 2.0 Complete API layer
  - [ ] 2.1 Write tests for API endpoints
    - Controller action tests (index, show, create, update, destroy)
    - Authentication/authorization tests
    - Request/response format tests
    - Error handling tests
  - [ ] 2.2 Create [resource] controller
    - Actions: index, show, create, update, destroy
    - Follow pattern from: [existing controller]
  - [ ] 2.3 Implement authentication/authorization
    - Use existing auth pattern
    - Add permission checks
  - [ ] 2.4 Add API response formatting
    - JSON responses
    - Error handling
    - Status codes
  - [ ] 2.5 Ensure all API layer tests pass
    - Run controller tests written in 2.1
    - Verify all CRUD operations work
    - Confirm proper authorization enforced

**Acceptance Criteria:**
- All tests written in 2.1 pass
- All CRUD operations work
- Proper authorization enforced
- Consistent response format

### Frontend Components

#### Task Group 3: UI Design
**Assigned implementer:** ui-designer
**Dependencies:** Task Group 2

- [ ] 3.0 Complete UI components
  - [ ] 3.1 Write tests for UI components
    - Component rendering tests
    - Form validation tests
    - User interaction tests
    - Responsive design tests
    - Accessibility tests
  - [ ] 3.2 Create [Component] component
    - Reuse: [existing component] as base
    - Props: [list]
    - State: [list]
  - [ ] 3.3 Implement [Feature] form
    - Fields: [list]
    - Validation: client-side
    - Submit handling
  - [ ] 3.4 Build [View] page
    - Layout: [description]
    - Components: [list]
    - Match mockup: `planning/visuals/[file]`
  - [ ] 3.5 Apply base styles
    - Follow existing design system
    - Use variables from: [style file]
  - [ ] 3.6 Implement responsive design
    - Mobile: 320px - 768px
    - Tablet: 768px - 1024px
    - Desktop: 1024px+
  - [ ] 3.7 Add interactions and animations
    - Hover states
    - Transitions
    - Loading states
  - [ ] 3.8 Ensure all UI component tests pass
    - Run component tests written in 3.1
    - Verify components render correctly
    - Confirm forms validate and submit properly

**Acceptance Criteria:**
- All tests written in 3.1 pass
- Components render correctly
- Forms validate and submit
- Matches visual design

### Testing

#### Task Group 4: End-to-End Testing & Validation
**Assigned implementer:** testing-engineer
**Dependencies:** Task Groups 1-3

- [ ] 4.0 Complete end-to-end test coverage
  - [ ] 4.1 Write end-to-end integration tests
    - Full user workflow tests
    - Cross-layer integration tests
    - API-to-UI data flow tests
    - Error scenario tests
  - [ ] 4.2 Create performance tests
    - Load testing for API endpoints
    - Frontend performance tests
    - Database query optimization tests
  - [ ] 4.3 Implement accessibility tests
    - Screen reader compatibility
    - Keyboard navigation tests
    - WCAG compliance tests
  - [ ] 4.4 Add browser compatibility tests
    - Cross-browser testing
    - Mobile device testing
    - Responsive design validation
  - [ ] 4.5 Validate all feature tests pass
    - Run all tests from Task Groups 1-3
    - Run new end-to-end tests from 4.1-4.4
    - Ensure 100% test coverage for new feature
    - Verify all edge cases are covered

**Acceptance Criteria:**
- All tests from previous task groups pass
- End-to-end user workflows work correctly
- 100% test coverage for new feature
- Performance meets requirements
- Accessibility standards met

## Execution Order

Recommended implementation sequence:
1. Database Layer (Task Group 1)
2. API Layer (Task Group 2)
3. Frontend Design (Task Group 3)
4. End-to-End Testing & Validation (Task Group 4)
```

**Note**: Adapt this structure based on the actual feature requirements. Some features may need:
- Different task groups (e.g., email notifications, payment processing, data migration)
- Different implementer (e.g., custom implementers from implementers.yml)
- Different execution order based on dependencies
- More or fewer sub-tasks per group

## Important Constraints

- **Base implementer assignments** on only the available implementers present in the list in implementers.yml.
- **Create tasks that are specific and verifiable**
- **Group related tasks** for efficient specialists implementer assignment
- **Use a test-driven development approach** where each task group starts with writing tests (x.1 sub-task) and ends with ensuring those tests pass (final sub-task).
- **Include acceptance criteria** for each task group
- **Reference visual assets** if visuals are available
